#!/usr/bin/env perl

# Assembles the instruction passed on stdin or as command line argument
# and displays its control vector

use strict;
use warnings;

use IO::Handle;
use Getopt::Std;
use File::Temp qw(tempdir tempfile);
use FindBin '$Bin';

my $workdir = "--workdir=$Bin/../vhdl/work";
my @opts = qw(--std=93c -fexplicit --ieee=synopsys);

my @args = @ARGV;
sub cmdline { shift @args }
my %opts;
BEGIN {getopts 'a:c:', \%opts; *arg = @ARGV ? \&cmdline : \&CORE::readline }

my $PREFIX   = $opts{p} // 'mips-';
my $packsize = $opts{s} // 'L>';

my $dir = tempdir(CLEANUP => 1);
my ($tmp1fh, $aout) = tempfile(DIR => $dir);
my ($tmp2fh, $bin)    = tempfile(DIR => $dir);
binmode($tmp2fh);
$tmp1fh->autoflush(1);

my $template_tb = do { local $/; <DATA> };
while (defined(my $instr = arg)) {
    chomp $instr;
    if ($instr !~ /^\s*[XB]?"[[:xdigit:]_]+"\s*$/) {
        # We got an instruction. Assemble it

        # pass as stdin to
        system "printf '.set mips1\n$instr\n' | ${PREFIX}as -EB -o$aout" and die;
        system "${PREFIX}objcopy -j .text -Obinary $aout $bin" and die;
        $instr = sprintf q/X"%08X"/, unpack($packsize, do { local $/; <$tmp2fh> });
    }

    my $tb = $template_tb =~ s/(\$\w+)/$1/geer;
    truncate $tmp1fh, 0;
    print $tmp1fh $tb;


    #system 'ghdl', '--remove', $workdir, "control_vec_test" and die;
    system 'ghdl', '-a', @opts, $workdir, $aout and die;
    system 'ghdl', '-e', @opts, $workdir, "control_vec_test" and die;
    my $out =  `ghdl -r @opts $workdir control_vec_test 2>&1` or die;
    $out =~ s/^.*\(assertion note\)://gm;

    print $out;
}

__DATA__
-- This was automatically generated by $0

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.arch_defs.all;
use work.txt_utils.all;

--  A testbench has no ports.
entity control_vec_test is
    end control_vec_test;

architecture behav of control_vec_test is

component maindec is
    port (  instr     : in std_logic_vector(31 downto 0); -- instruction_t
            regwrite, regdst, link, jumpreg, jumpdirect, branch : out ctrl_t;
            memread : out ctrl_memwidth_t;
            memtoreg, memsex : out ctrl_t;
            memwrite : out ctrl_memwidth_t;
            shift, alusrc : out ctrl_t;
            aluop     : out alu_op_t);
    end component;
    signal instr     : std_logic_vector(31 downto 0); -- instruction_t

    signal regwrite, regdst, link, jumpreg, jumpdirect, branch : ctrl_t;
    signal memread : ctrl_memwidth_t;
    signal memtoreg, memsex : ctrl_t;
    signal memwrite : ctrl_memwidth_t;
    signal shift, alusrc : ctrl_t;
    signal aluop     : alu_op_t;
    alias op is instr(31 downto 26);
    alias rs is instr(25 downto 21);
    alias rt is instr(20 downto 16);
    alias rd is instr(15 downto 11);
    alias shamt is instr(10 downto 6);
    alias func is instr(5 downto 0);
    alias address is instr(25 downto 0);
    alias imm is instr(15 downto 0);

    alias b is TO_BSTRING [STD_LOGIC_VECTOR return STRING];
    alias b is TO_STRING [STD_ULOGIC return STRING];
    constant d : string := "|";
    begin
        control : maindec port map(
                instr,
                regwrite, regdst, link, jumpreg, jumpdirect, branch,
                memread,
                memtoreg,
                memsex,
                memwrite,
                shift, alusrc,
                aluop);

        printer: process
        begin
            instr <= $instr;

            wait for 1000 ns;

            if is_type_r(instr) then
                assert false report Character'val(10)&

                    "   :   6  :   5  :   5  :   5  :   5   :   6  :"&Character'val(10)&
                    "   .------------------------------------------." &Character'val(10)&
                    " R |opcode|  rs  |  rt  |  rd  | shamt | func |" &Character'val(10)&
                    "   |------------------------------------------|" &Character'val(10)&
                    "   |"&b(op)&"| "&b(rs)&"| "&b(rt)&"| "&b(rd)&"| "&b(shamt)&" |"&b(func)&"|"&Character'Val(10)&
                    "   '------------------------------------------'"&Character'Val(10)&
                    "   :31  26:25  21:20  16:15  11:10    6:5    0:"&Character'val(10)
                    severity note;
            elsif is_type_j(instr) then
                assert false report Character'val(10)&

                    "   :   6  :               26                  :"&Character'val(10)&
                    "   .------------------------------------------." &Character'val(10)&
                    " J |opcode|              address              |" &Character'val(10)&
                    "   |------------------------------------------|" &Character'val(10)&
                    "   |"&b(op)&"|     "     &b(address)&    "    |"&Character'Val(10)&
                    "   '------------------------------------------'"&Character'Val(10)&
                    "   :31  26:25                                0:" &Character'val(10)
                    severity note;
            elsif is_type_i(instr) then
                assert false report Character'val(10)&

                    "   :   6  :   5  :   5  :         16          :"&Character'val(10)&
                    "   .------------------------------------------." &Character'val(10)&
                    " I |opcode|  rs  |  rt  |      immediate      |" &Character'val(10)&
                    "   |------------------------------------------|" &Character'val(10)&
                    "   |"&b(op)&"| "&b(rs)&"| "&b(rt)&"|   "&b(imm)&"  |" &Character'val(10)&
                    "   '------------------------------------------'"&Character'Val(10)&
                    "   :31  26:25  21:20  16:15                  0:" &Character'val(10)
                    severity note;
            end if;

            assert false report
            "0b" & to_bstring(instr) & " (0x" & to_hstring(instr) & ")" &
           Character'val(10)& "RegWrite     = " & to_string(regwrite) &
           Character'val(10)& "RegDst (rd)  = " & to_string(regdst) &
           Character'val(10)& "Link         = " & to_string(link) &
           Character'val(10)& "JumpReg      = " & to_string(jumpreg) &
           Character'val(10)& "JumpDirect   = " & to_string(jumpdirect) &
           Character'val(10)& "Branch       = " & to_string(branch) &
           Character'val(10)& "MemRead      = " & to_string(memread) &
           Character'val(10)& "MemtoReg     = " & to_string(memtoreg) &
           Character'val(10)& "SignExtend   = " & to_string(memsex) &
           Character'val(10)& "MemWrite     = " & to_string(memwrite) &
           Character'val(10)& "Shift        = " & to_string(shift) &
           Character'val(10)& "AluSrc (Imm) = " & to_string(alusrc) &
           Character'val(10)& "AluOp        = " & alu_op_t'image(aluop)
            severity note;

            wait;
    end process;
end behav;

